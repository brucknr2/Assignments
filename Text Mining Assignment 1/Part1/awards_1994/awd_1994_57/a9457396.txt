Title       : NSF Young Investigator: Design Automation for Embedded Systems
Type        : Award
NSF Org     : CCR 
Latest
Amendment
Date        : July 22,  1999      
File        : a9457396

Award Number: 9457396
Award Instr.: Continuing grant                             
Prgm Manager: Robert B. Grafton                       
	      CCR  DIV OF COMPUTER-COMMUNICATIONS RESEARCH 
	      CSE  DIRECT FOR COMPUTER & INFO SCIE & ENGINR
Start Date  : September 1,  1994  
Expires     : August 31,  1999     (Estimated)
Expected
Total Amt.  : $312500             (Estimated)
Investigator: Sharad Malik Sharad@ee.princeton.edu  (Principal Investigator current)
Sponsor     : Princeton University
	      
	      Princeton, NJ  08544    609/452-3000

NSF Program : 4710      DESIGN AUTOMATION PROGRAM
Fld Applictn: 0206000   Telecommunications                      
              0510403   Engineering & Computer Science          
              31        Computer Science & Engineering          
              55        Engineering-Electrical                  
Program Ref : 9215,9227,9297,HPCC,
Abstract    :
              High fabrication costs coupled with decreasing time-to-market for  products
              require an increase of the programmable component of  integrated circuits. 
              Core processors embedded in a gate array  provide programmability.  This
              changes circuit design from just  gates in an array, to a combination of
              instructions running on a  core processor coupled with a gate array.  Gates, as
              basic units of  computation on silicon, are well understood.  This research is 
              focused on understanding embedded instructions as basic units of  computation
              on silicon.  Initial work is on finding methodologies  for synthesizing
              embedded software.  Problems being examined are:  worst case timing analysis;
              power modeling and analysis; and high-  quality retargetable code synthesis. 
              Approaches include:  developing timing models capable of handling features such
              as  caches and pipelines, and determining worst-case paths; analyzing  system
              power consumption; and formal architectural specification of  specialized
              architectures, as well as code-generation algorithms  that can take advantage
              of special architectures.
